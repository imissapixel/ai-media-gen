<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>AI Media Generator</title>
    
    <!-- PWA Meta Tags -->
    <meta name="description" content="Generate AI-powered images and videos with advanced customization options">
    <meta name="theme-color" content="#667eea">
    <meta name="mobile-web-app-capable" content="yes">
    <meta name="apple-mobile-web-app-capable" content="yes">
    <meta name="apple-mobile-web-app-status-bar-style" content="default">
    <meta name="apple-mobile-web-app-title" content="AI Media Gen">
    <meta name="msapplication-TileColor" content="#667eea">
    
    <!-- Favicon -->
    <link rel="icon" type="image/svg+xml" href="logo.svg">
    <link rel="apple-touch-icon" href="logo.svg">
    
    <!-- Web App Manifest -->
    <link rel="manifest" href="manifest.json">
    <style>
        /* General Reset & Body Styling */
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, Oxygen, Ubuntu, Cantarell, sans-serif;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            min-height: 100vh;
            display: flex;
            align-items: flex-start;
            justify-content: center;
            padding: 20px;
            padding-top: 40px;
        }

        /* Main Container */
        .container {
            background: rgba(255, 255, 255, 0.95);
            backdrop-filter: blur(10px);
            border-radius: 20px;
            box-shadow: 0 25px 50px rgba(0, 0, 0, 0.1);
            padding: 40px;
            width: 100%;
            max-width: 600px;
            min-height: 500px;
            transition: all 0.3s ease;
        }

        .container:hover {
            transform: translateY(-5px);
            box-shadow: 0 35px 60px rgba(0, 0, 0, 0.15);
        }

        /* Header */
        .header {
            text-align: center;
            margin-bottom: 30px;
        }

        .title {
            font-size: 28px;
            font-weight: 700;
            color: #2d3748;
            margin-bottom: 8px;
        }

        .subtitle {
            color: #718096;
            font-size: 16px;
        }

        /* Tab Navigation */
        .tab-navigation {
            display: flex;
            border-bottom: 2px solid #e2e8f0;
            margin-bottom: 30px;
            border-radius: 8px 8px 0 0;
            overflow: hidden;
        }

        .tab-button {
            flex: 1;
            padding: 15px 20px;
            background: #f7fafc;
            border: none;
            cursor: pointer;
            font-weight: 600;
            color: #718096;
            transition: all 0.3s ease;
            font-size: 16px;
        }

        .tab-button.active {
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            color: white;
        }

        .tab-button:hover:not(.active) {
            background: #edf2f7;
            color: #4a5568;
        }

        /* Tab Content */
        .tab-content {
            display: none;
        }

        .tab-content.active {
            display: block;
        }

        /* Form Styling */
        .form-group {
            margin-bottom: 25px;
        }

        .form-label {
            display: block;
            font-weight: 600;
            color: #4a5568;
            margin-bottom: 8px;
            font-size: 14px;
            text-transform: uppercase;
            letter-spacing: 0.5px;
        }

        .form-input,
        .form-select {
            width: 100%;
            padding: 15px 20px;
            border: 2px solid #e2e8f0;
            border-radius: 12px;
            font-size: 16px;
            background: #ffffff;
            transition: all 0.3s ease;
            -webkit-appearance: none;
            -moz-appearance: none;
            appearance: none;
        }

        .form-input:focus,
        .form-select:focus {
            outline: none;
            border-color: #667eea;
            box-shadow: 0 0 0 3px rgba(102, 126, 234, 0.1);
            transform: translateY(-2px);
        }

        .form-select {
            background-image: url("data:image/svg+xml,%3csvg xmlns='http://www.w3.org/2000/svg' fill='none' viewBox='0 0 20 20'%3e%3cpath stroke='%236b7280' stroke-linecap='round' stroke-linejoin='round' stroke-width='1.5' d='m6 8 4 4 4-4'/%3e%3c/svg%3e");
            background-position: right 1rem center;
            background-repeat: no-repeat;
            background-size: 1.25em;
            cursor: pointer;
        }

        .form-textarea {
            resize: vertical;
            min-height: 100px;
        }

        /* File Upload Styling */
        .file-upload {
            position: relative;
            display: inline-block;
            width: 100%;
        }

        .file-upload input[type=file] {
            position: absolute;
            left: -9999px;
        }

        .file-upload-label {
            display: block;
            width: 100%;
            padding: 15px 20px;
            border: 2px dashed #e2e8f0;
            border-radius: 12px;
            text-align: center;
            cursor: pointer;
            transition: all 0.3s ease;
            background: #f7fafc;
            color: #718096;
        }

        .file-upload-label:hover {
            border-color: #667eea;
            background: #edf2f7;
        }

        .file-upload-label.has-file {
            border-color: #38a169;
            background: #f0fff4;
            color: #38a169;
        }

        /* Radio Button Group */
        .radio-group {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(100px, 1fr));
            gap: 15px;
        }

        .radio-option {
            min-width: 100px;
        }

        .radio-option input[type="radio"] {
            display: none;
        }

        .radio-option label {
            display: block;
            padding: 8px 12px;
            border: 2px solid #e2e8f0;
            border-radius: 6px;
            text-align: center;
            cursor: pointer;
            transition: all 0.3s ease;
            background: #ffffff;
            color: #4a5568;
            font-weight: 500;
            font-size: 14px;
        }

        .radio-option input[type="radio"]:checked + label {
            border-color: #667eea;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            color: white;
        }

        .radio-option label:hover {
            border-color: #667eea;
        }

        /* Button & State Styling */
        .submit-btn {
            width: 100%;
            background: linear-gradient(135deg, #4299e1 0%, #3182ce 100%);
            color: white;
            border: none;
            padding: 18px 24px;
            border-radius: 12px;
            font-size: 16px;
            font-weight: 600;
            cursor: pointer;
            transition: all 0.3s ease;
            text-transform: uppercase;
            letter-spacing: 0.5px;
        }

        .submit-btn:hover:not(:disabled) {
            transform: translateY(-2px);
            box-shadow: 0 10px 25px rgba(66, 153, 225, 0.3);
            background: linear-gradient(135deg, #3182ce 0%, #2c5aa0 100%);
        }

        .submit-btn:disabled {
            opacity: 0.6;
            cursor: not-allowed;
        }
        
        /* Message & Loading Indicators */
        .loading, .video-container, .image-container, .error-message, .success-message {
            display: none;
            margin-top: 20px;
        }
        
        .loading.show, .video-container.show, .image-container.show, .error-message.show, .success-message.show {
            display: block;
        }

        .loading {
            text-align: center;
        }

        .loading-spinner {
            width: 40px;
            height: 40px;
            border: 4px solid #e2e8f0;
            border-top: 4px solid #667eea;
            border-radius: 50%;
            animation: spin 1s linear infinite;
            margin: 0 auto 15px;
        }

        @keyframes spin {
            0% { transform: rotate(0deg); }
            100% { transform: rotate(360deg); }
        }

        .loading-text {
            color: #718096;
            font-size: 16px;
        }
        
        .message-box {
            color: white;
            padding: 15px;
            border-radius: 8px;
            text-align: center;
        }

        .error-message {
            background: #e53e3e;
        }

        .success-message {
            background: #38a169;
        }

        /* Settings collapse functionality */
        .settings-collapsed {
            max-height: 0;
            overflow: hidden;
            opacity: 0;
            transition: all 0.3s ease;
            pointer-events: none;
        }

        .settings-expanded {
            max-height: none;
            opacity: 1;
            transition: all 0.3s ease;
            pointer-events: auto;
        }

        /* Action buttons for generated content */
        .action-buttons {
            display: none;
            margin: 20px 0;
            text-align: center;
            gap: 15px;
        }

        .action-buttons.show {
            display: flex;
            justify-content: center;
            align-items: center;
        }

        .action-btn {
            padding: 12px 24px;
            border: none;
            border-radius: 8px;
            font-size: 14px;
            font-weight: 600;
            cursor: pointer;
            transition: all 0.3s ease;
            text-transform: uppercase;
            letter-spacing: 0.5px;
        }

        .generate-another-btn {
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            color: white;
        }

        .generate-another-btn:hover {
            transform: translateY(-2px);
            box-shadow: 0 5px 15px rgba(102, 126, 234, 0.3);
        }

        .download-btn {
            background: #38a169;
            color: white;
        }

        .download-btn:hover {
            background: #2f855a;
            transform: translateY(-2px);
            box-shadow: 0 5px 15px rgba(56, 161, 105, 0.3);
        }

        /* Gallery Styles */
        .gallery-title {
            text-align: center;
            font-size: 20px;
            font-weight: 600;
            color: #4a5568;
            margin-bottom: 8px;
        }
        
        .gallery-subtitle {
            text-align: center;
            font-size: 12px;
            color: #718096;
            margin-bottom: 20px;
        }
        
        .gallery-grid {
            display: grid;
            grid-template-columns: repeat(3, 1fr);
            gap: 20px;
            margin-top: 20px;
        }

        .gallery-item {
            position: relative;
            border-radius: 12px;
            overflow: hidden;
            box-shadow: 0 4px 12px rgba(0, 0, 0, 0.1);
            transition: transform 0.3s ease, box-shadow 0.3s ease;
            cursor: pointer;
            aspect-ratio: 1;
        }

        .gallery-item:hover {
            transform: translateY(-2px);
            box-shadow: 0 8px 20px rgba(0, 0, 0, 0.15);
        }

        .gallery-item-media {
            width: 100%;
            height: 100%;
            object-fit: cover;
            background: #f7fafc;
        }

        .gallery-item-type {
            position: absolute;
            top: 8px;
            left: 8px;
            font-size: 20px;
            text-shadow: 0 2px 4px rgba(0, 0, 0, 0.5);
        }

        .gallery-item-delete {
            position: absolute;
            top: 8px;
            right: 8px;
            width: 24px;
            height: 24px;
            background: rgba(239, 68, 68, 0.9);
            color: white;
            border: none;
            border-radius: 50%;
            font-size: 14px;
            font-weight: bold;
            cursor: pointer;
            display: flex;
            align-items: center;
            justify-content: center;
            transition: all 0.3s ease;
            backdrop-filter: blur(4px);
        }

        .gallery-item-delete:hover {
            background: rgba(220, 38, 38, 1);
            transform: scale(1.1);
        }

        .gallery-empty {
            text-align: center;
            padding: 60px 20px;
            color: #718096;
        }

        .gallery-empty-icon {
            font-size: 48px;
            margin-bottom: 16px;
        }

        .gallery-clear-all {
            text-align: center;
            margin-top: 30px;
            margin-bottom: 20px;
        }

        .clear-all-btn {
            background: #e53e3e;
            color: white;
            border: none;
            padding: 8px 16px;
            border-radius: 6px;
            font-size: 12px;
            font-weight: 600;
            cursor: pointer;
            transition: all 0.3s ease;
        }

        .clear-all-btn:hover {
            background: #c53030;
        }

        .clear-browser-data-link {
            text-align: center;
            margin-top: 30px;
            padding-bottom: 20px;
        }

        .clear-browser-data-link a {
            color: #718096;
            font-size: 11px;
            text-decoration: none;
            opacity: 0.7;
            transition: all 0.3s ease;
        }

        .clear-browser-data-link a:hover {
            color: #4a5568;
            opacity: 1;
            text-decoration: underline;
        }

        /* Improve Prompt Button */
        .improve-prompt-btn {
            width: 100%;
            background: linear-gradient(135deg, #9f7aea 0%, #805ad5 100%);
            color: white;
            border: none;
            padding: 12px 20px;
            border-radius: 8px;
            font-size: 14px;
            font-weight: 600;
            cursor: pointer;
            transition: all 0.3s ease;
            margin-top: 8px;
            text-transform: uppercase;
            letter-spacing: 0.5px;
        }

        .improve-prompt-btn:hover:not(:disabled) {
            transform: translateY(-1px);
            box-shadow: 0 4px 12px rgba(159, 122, 234, 0.3);
            background: linear-gradient(135deg, #805ad5 0%, #6b46c1 100%);
        }

        .improve-prompt-btn:disabled {
            opacity: 0.6;
            cursor: not-allowed;
            transform: none;
        }

        /* Modal for full-size viewing */
        .modal {
            display: none;
            position: fixed;
            z-index: 1000;
            left: 0;
            top: 0;
            width: 100%;
            height: 100%;
            background-color: rgba(0, 0, 0, 0.9);
        }

        .modal.show {
            display: flex;
            justify-content: center;
            align-items: center;
        }

        .modal-content {
            max-width: 90%;
            max-height: 90%;
            border-radius: 12px;
            position: relative;
            display: flex;
            flex-direction: column;
            align-items: center;
        }

        .modal-close {
            position: absolute;
            top: -40px;
            right: 0;
            color: white;
            font-size: 28px;
            font-weight: bold;
            cursor: pointer;
            padding: 5px;
        }

        .modal-close:hover {
            opacity: 0.7;
        }

        .modal-info {
            background: rgba(255, 255, 255, 0.95);
            color: #2d3748;
            padding: 20px;
            border-radius: 8px;
            margin-top: 20px;
            backdrop-filter: blur(10px);
        }

        .modal-prompt {
            font-size: 16px;
            margin-bottom: 10px;
            line-height: 1.4;
        }

        .modal-settings {
            font-size: 14px;
            color: #4a5568;
            display: flex;
            gap: 15px;
            flex-wrap: wrap;
        }

        .modal-date {
            font-size: 12px;
            color: #718096;
            margin-top: 8px;
        }

        /* Background Jobs Status */
        .background-jobs-status {
            background: rgba(102, 126, 234, 0.1);
            border: 1px solid rgba(102, 126, 234, 0.2);
            border-radius: 12px;
            padding: 20px;
            margin-bottom: 30px;
        }

        .background-jobs-title {
            font-size: 16px;
            font-weight: 600;
            color: #4a5568;
            margin-bottom: 15px;
            display: flex;
            align-items: center;
            gap: 8px;
        }

        .background-jobs-list {
            display: flex;
            flex-direction: column;
            gap: 12px;
        }

        .background-job-item {
            background: white;
            border-radius: 8px;
            padding: 15px;
            display: flex;
            align-items: center;
            gap: 12px;
            box-shadow: 0 2px 8px rgba(0, 0, 0, 0.1);
        }

        .background-job-icon {
            font-size: 20px;
            width: 24px;
            text-align: center;
        }

        .background-job-content {
            flex: 1;
        }

        .background-job-type {
            font-size: 14px;
            font-weight: 600;
            color: #4a5568;
            text-transform: capitalize;
        }

        .background-job-prompt {
            font-size: 12px;
            color: #718096;
            margin-top: 2px;
            overflow: hidden;
            text-overflow: ellipsis;
            white-space: nowrap;
            max-width: 200px;
        }

        .background-job-spinner {
            width: 20px;
            height: 20px;
            border: 2px solid #e2e8f0;
            border-top: 2px solid #667eea;
            border-radius: 50%;
            animation: spin 1s linear infinite;
            flex-shrink: 0;
        }

        .background-job-time {
            font-size: 11px;
            color: #a0aec0;
            margin-top: 4px;
        }

        /* PWA Install Banner */
        .pwa-install-banner {
            position: fixed;
            top: 0;
            left: 0;
            right: 0;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            color: white;
            padding: 12px 20px;
            z-index: 1001;
            display: none;
            align-items: center;
            justify-content: space-between;
            box-shadow: 0 2px 10px rgba(0, 0, 0, 0.1);
            font-size: 14px;
            line-height: 1.4;
        }

        .pwa-install-banner.show {
            display: flex;
        }

        .pwa-banner-content {
            display: flex;
            align-items: center;
            gap: 12px;
            flex: 1;
        }

        .pwa-banner-icon {
            font-size: 20px;
            flex-shrink: 0;
        }

        .pwa-banner-text {
            flex: 1;
        }

        .pwa-banner-title {
            font-weight: 600;
            margin-bottom: 2px;
        }

        .pwa-banner-subtitle {
            font-size: 12px;
            opacity: 0.9;
        }

        .pwa-banner-actions {
            display: flex;
            gap: 8px;
            align-items: center;
        }

        .pwa-banner-btn {
            background: rgba(255, 255, 255, 0.2);
            color: white;
            border: 1px solid rgba(255, 255, 255, 0.3);
            padding: 6px 12px;
            border-radius: 6px;
            font-size: 12px;
            font-weight: 600;
            cursor: pointer;
            transition: all 0.3s ease;
            white-space: nowrap;
        }

        .pwa-banner-btn:hover {
            background: rgba(255, 255, 255, 0.3);
        }

        .pwa-banner-btn.primary {
            background: rgba(255, 255, 255, 0.9);
            color: #667eea;
        }

        .pwa-banner-btn.primary:hover {
            background: white;
        }

        .pwa-banner-close {
            background: none;
            border: none;
            color: white;
            font-size: 18px;
            cursor: pointer;
            padding: 4px;
            margin-left: 8px;
            opacity: 0.8;
            transition: opacity 0.3s ease;
        }

        .pwa-banner-close:hover {
            opacity: 1;
        }

        .pwa-safari-instructions {
            font-size: 12px;
            margin-top: 8px;
            padding-top: 8px;
            border-top: 1px solid rgba(255, 255, 255, 0.2);
            line-height: 1.3;
        }

        .pwa-safari-step {
            display: flex;
            align-items: center;
            gap: 6px;
            margin: 2px 0;
        }

        /* Adjust main container when banner is visible */
        body.pwa-banner-visible {
            padding-top: 80px;
        }

        @media (max-width: 640px) {
            body.pwa-banner-visible {
                padding-top: 120px;
            }
            
            .pwa-install-banner {
                flex-direction: column;
                align-items: flex-start;
                gap: 12px;
                padding: 16px 20px;
            }
            
            .pwa-banner-content {
                width: 100%;
            }
            
            .pwa-banner-actions {
                width: 100%;
                justify-content: flex-end;
            }
        }

        /* Media Players */
        .video-container, .image-container {
            text-align: center;
        }

        .video-player {
            width: 100%;
            max-width: 100%;
            border-radius: 12px;
            box-shadow: 0 10px 25px rgba(0, 0, 0, 0.1);
            background-color: #000;
        }

        .generated-image {
            max-width: 100%;
            height: auto;
            border-radius: 12px;
            box-shadow: 0 10px 25px rgba(0, 0, 0, 0.1);
        }

        /* Responsive Design */
        @media (max-width: 640px) {
            body {
                padding: 10px;
                padding-top: 20px;
            }
            .container {
                padding: 20px 15px;
                margin: 0;
                max-width: none;
                border-radius: 15px;
            }
            .title {
                font-size: 24px;
            }
            .radio-group {
                grid-template-columns: repeat(auto-fit, minmax(55px, 1fr));
                gap: 4px;
            }
            .radio-option {
                min-width: unset;
            }
            .radio-option label {
                padding: 5px 2px;
                font-size: 11px;
            }
        }
    </style>
</head>
<body>
    <!-- PWA Install Banner -->
    <div id="pwaInstallBanner" class="pwa-install-banner">
        <div class="pwa-banner-content">
            <div class="pwa-banner-icon">📱</div>
            <div class="pwa-banner-text">
                <div class="pwa-banner-title">Install AI Media Generator</div>
                <div class="pwa-banner-subtitle">Get the full app experience for best convenience</div>
                <div id="safariInstructions" class="pwa-safari-instructions" style="display: none;">
                    <div class="pwa-safari-step">1. Tap the <strong>Share</strong> button ⤴️</div>
                    <div class="pwa-safari-step">2. Scroll down and tap <strong>"Add to Home Screen"</strong> ➕</div>
                    <div class="pwa-safari-step">3. Tap <strong>"Add"</strong> to install</div>
                </div>
            </div>
        </div>
        <div class="pwa-banner-actions">
            <button id="pwaInstallBtn" class="pwa-banner-btn primary" style="display: none;">Install</button>
            <button id="pwaShowInstructions" class="pwa-banner-btn" style="display: none;">How to Install</button>
            <button id="pwaLaterBtn" class="pwa-banner-btn">Later</button>
        </div>
        <button id="pwaDismissBtn" class="pwa-banner-close">&times;</button>
    </div>

    <div class="container">
        <div class="header">
            <h1 class="title">AI Media Generator</h1>
        </div>

        <!-- Tab Navigation -->
        <div class="tab-navigation">
            <button class="tab-button active" data-tab="image">🎨 Image</button>
            <button class="tab-button" data-tab="video">🎬 Video</button>
            <button class="tab-button" data-tab="gallery">🖼️ Gallery</button>
        </div>

        <!-- Image Generation Tab -->
        <div id="image-tab" class="tab-content active">
            <form id="imageForm" class="settings-expanded">
                <div class="form-group">
                    <label for="inputImage" class="form-label">Input Image (Optional)</label>
                    <div class="file-upload">
                        <input type="file" id="inputImage" name="inputImage" accept="image/*">
                        <label for="inputImage" class="file-upload-label" id="imageUploadLabel">
                            📁 Choose an image file (optional)
                        </label>
                    </div>
                </div>

                <div class="form-group">
                    <label for="imagePrompt" class="form-label">Image Prompt</label>
                    <textarea 
                        id="imagePrompt" 
                        name="imagePrompt" 
                        class="form-input form-textarea" 
                        placeholder="e.g., A futuristic cityscape at sunset with flying cars"
                        required
                    ></textarea>
                    <button type="button" class="improve-prompt-btn" id="improvePromptBtn">
                        🪄 Improve Prompt
                    </button>
                </div>

                <div class="form-group">
                    <label class="form-label">Size</label>
                    <div class="radio-group">
                        <div class="radio-option">
                            <input type="radio" id="size1" name="size" value="1024x1024" checked required>
                            <label for="size1">1024×1024<br><small>Square</small></label>
                        </div>
                        <div class="radio-option">
                            <input type="radio" id="size2" name="size" value="1024x1536" required>
                            <label for="size2">1024×1536<br><small>Portrait</small></label>
                        </div>
                        <div class="radio-option">
                            <input type="radio" id="size3" name="size" value="1536x1024" required>
                            <label for="size3">1536×1024<br><small>Landscape</small></label>
                        </div>
                    </div>
                </div>

                <div class="form-group">
                    <label class="form-label">Quality</label>
                    <div class="radio-group">
                        <div class="radio-option">
                            <input type="radio" id="quality1" name="quality" value="low" checked required>
                            <label for="quality1">Low</label>
                        </div>
                        <div class="radio-option">
                            <input type="radio" id="quality2" name="quality" value="medium" required>
                            <label for="quality2">Medium</label>
                        </div>
                        <div class="radio-option">
                            <input type="radio" id="quality3" name="quality" value="high" required>
                            <label for="quality3">High</label>
                        </div>
                    </div>
                </div>

                <div class="form-group">
                    <label class="form-label">Output Format</label>
                    <div class="radio-group">
                        <div class="radio-option">
                            <input type="radio" id="outputFormat1" name="outputFormat" value="jpeg" checked required>
                            <label for="outputFormat1">JPG</label>
                        </div>
                        <div class="radio-option">
                            <input type="radio" id="outputFormat2" name="outputFormat" value="png" required>
                            <label for="outputFormat2">PNG</label>
                        </div>
                    </div>
                </div>

                <button type="submit" class="submit-btn" id="imageSubmitBtn">
                    Generate Image
                </button>
            </form>

            <!-- Image Status Indicators -->
            <div class="loading" id="imageLoading">
                <div class="loading-spinner"></div>
                <div class="loading-text">Creating your image masterpiece... Please wait.</div>
            </div>

            <div class="success-message message-box" id="imageSuccessMessage">
                ✅ Image generated successfully!
            </div>

            <div class="error-message message-box" id="imageErrorMessage">
                ❌ <span id="imageErrorText"></span>
            </div>

            <!-- Action buttons for image -->
            <div class="action-buttons" id="imageActionButtons">
                <button class="action-btn generate-another-btn" data-action="show-image-settings">Generate Another</button>
                <button class="action-btn download-btn" data-action="download-image">Download</button>
            </div>

            <!-- Image Container -->
            <div class="image-container" id="imageContainer">
                <img id="generatedImage" class="generated-image" alt="Generated Image">
            </div>
        </div>

        <!-- Video Generation Tab -->
        <div id="video-tab" class="tab-content">
            <form id="videoForm" class="settings-expanded">
                <div class="form-group">
                    <label for="videoDescription" class="form-label">Video Description</label>
                    <textarea 
                        id="videoDescription" 
                        name="videoDescription" 
                        class="form-input form-textarea" 
                        placeholder="e.g., A cinematic shot of an astronaut riding a horse on Mars"
                        required
                    ></textarea>
                    <button type="button" class="improve-prompt-btn" id="improveVideoPromptBtn">
                        🪄 Improve Prompt
                    </button>
                </div>

                <div class="form-group">
                    <label class="form-label">Duration</label>
                    <div class="radio-group">
                        <div class="radio-option">
                            <input type="radio" id="duration1" name="duration" value="5" checked required>
                            <label for="duration1">5 sec</label>
                        </div>
                        <div class="radio-option">
                            <input type="radio" id="duration2" name="duration" value="10" required>
                            <label for="duration2">10 sec</label>
                        </div>
                        <div class="radio-option">
                            <input type="radio" id="duration3" name="duration" value="15" required>
                            <label for="duration3">15 sec</label>
                        </div>
                        <div class="radio-option">
                            <input type="radio" id="duration4" name="duration" value="20" required>
                            <label for="duration4">20 sec</label>
                        </div>
                    </div>
                </div>

                <div class="form-group">
                    <label class="form-label">Aspect Ratio</label>
                    <div class="radio-group">
                        <div class="radio-option">
                            <input type="radio" id="aspect3" name="aspectRatio" value="1:1" checked required>
                            <label for="aspect3">1:1<br><small>Square</small></label>
                        </div>
                        <div class="radio-option">
                            <input type="radio" id="aspect1" name="aspectRatio" value="16:9" required>
                            <label for="aspect1">16:9<br><small>Landscape</small></label>
                        </div>
                        <div class="radio-option">
                            <input type="radio" id="aspect2" name="aspectRatio" value="9:16" required>
                            <label for="aspect2">9:16<br><small>Portrait</small></label>
                        </div>
                    </div>
                </div>

                <div class="form-group">
                    <label class="form-label">Video Format</label>
                    <div class="radio-group">
                        <div class="radio-option">
                            <input type="radio" id="format1" name="format" value="480p" checked required>
                            <label for="format1">480p<br><small>SD</small></label>
                        </div>
                        <div class="radio-option">
                            <input type="radio" id="format2" name="format" value="720p" required>
                            <label for="format2">720p<br><small>HD</small></label>
                        </div>
                        <div class="radio-option">
                            <input type="radio" id="format3" name="format" value="1080p" required>
                            <label for="format3">1080p<br><small>Full HD</small></label>
                        </div>
                    </div>
                </div>

                <button type="submit" class="submit-btn" id="videoSubmitBtn">
                    Generate Video
                </button>
            </form>

            <!-- Video Status Indicators -->
            <div class="loading" id="videoLoading">
                <div class="loading-spinner"></div>
                <div class="loading-text">Generating your video masterpiece... Please wait.</div>
            </div>

            <div class="success-message message-box" id="videoSuccessMessage">
                ✅ Video generated successfully!
            </div>

            <div class="error-message message-box" id="videoErrorMessage">
                ❌ <span id="videoErrorText"></span>
            </div>

            <!-- Action buttons for video -->
            <div class="action-buttons" id="videoActionButtons">
                <button class="action-btn generate-another-btn" data-action="show-video-settings">Generate Another</button>
                <button class="action-btn download-btn" data-action="download-video">Download</button>
            </div>

            <!-- Video Player Container -->
            <div class="video-container" id="videoContainer">
                <video id="videoPlayer" class="video-player" controls>
                    Your browser does not support the video tag.
                </video>
            </div>
        </div>

        <!-- Gallery Tab -->
        <div id="gallery-tab" class="tab-content">
            <!-- Background Jobs Status -->
            <div id="backgroundJobsStatus" class="background-jobs-status" style="display: none;">
                <div class="background-jobs-title">🔄 Background Generation</div>
                <div id="backgroundJobsList" class="background-jobs-list">
                    <!-- Active background jobs will be shown here -->
                </div>
            </div>
            
            <div class="gallery-title">Your last 50 generations</div>
            <div class="gallery-subtitle">All content is stored offline in your device</div>
            <div id="galleryContent">
                <!-- Gallery items will be loaded here -->
            </div>
            <div class="gallery-clear-all">
                <button class="clear-all-btn" data-action="clear-gallery">Clear All</button>
            </div>
            
            <!-- Always visible clear browser data link -->
            <div class="clear-browser-data-link">
                <a href="#" data-action="clear-browser-data">Clear all browser data</a>
            </div>
        </div>
    </div>

    <!-- Modal for full-size viewing -->
    <div id="mediaModal" class="modal">
        <span class="modal-close" data-action="close-modal">&times;</span>
        <div class="modal-content">
            <div style="max-height: 70vh; display: flex; align-items: center;">
                <img id="modalImage" style="display: none; max-width: 100%; max-height: 100%; border-radius: 12px;">
                <video id="modalVideo" style="display: none; max-width: 100%; max-height: 100%; border-radius: 12px;" controls>
                    Your browser does not support the video tag.
                </video>
            </div>
            <div id="modalInfo" class="modal-info">
                <div id="modalPrompt" class="modal-prompt"></div>
                <div id="modalSettings" class="modal-settings"></div>
                <div id="modalDate" class="modal-date"></div>
            </div>
        </div>
    </div>

    <script>
        // Client-side Webhook Throttling System
        // Purpose: This system is primarily a UX enhancement to prevent users from
        // accidentally sending multiple rapid requests (e.g., double-clicking the generate button).
        // It helps avoid unnecessary duplicate processing and user frustration.
        // IMPORTANT: This is NOT a robust security measure against deliberate abuse or attacks.
        // True rate limiting and security must be implemented server-side on the webhook endpoints.
        const WEBHOOK_THROTTLE_DURATION = 15000; // 15 seconds
        const webhookThrottleState = {
            lastVideoCall: 0,
            lastImageCall: 0,
            deviceFingerprint: null
        };

        // Generate a device fingerprint for client-side identification.
        // This is a basic heuristic and not a foolproof security measure.
        // It's used here as part of the client-side UX throttling strategy and potentially for server-side logging.
        function generateDeviceFingerprint() {
            if (webhookThrottleState.deviceFingerprint) {
                return webhookThrottleState.deviceFingerprint;
            }
            
            const canvas = document.createElement('canvas');
            const ctx = canvas.getContext('2d');
            ctx.textBaseline = 'top';
            ctx.font = '14px Arial';
            ctx.fillText('Device fingerprint', 2, 2);
            
            const fingerprint = [
                navigator.userAgent,
                navigator.language,
                screen.width + 'x' + screen.height,
                new Date().getTimezoneOffset(),
                canvas.toDataURL()
            ].join('|');
            
            // Create a simple hash of the fingerprint
            let hash = 0;
            for (let i = 0; i < fingerprint.length; i++) {
                const char = fingerprint.charCodeAt(i);
                hash = ((hash << 5) - hash) + char;
                hash = hash & hash; // Convert to 32-bit integer
            }
            
            webhookThrottleState.deviceFingerprint = 'fp_' + Math.abs(hash).toString(36);
            return webhookThrottleState.deviceFingerprint;
        }

        // Check if a webhook call is allowed based on the client-side throttle.
        // This is primarily for UX to prevent rapid duplicate submissions.
        // It is NOT a security feature and can be bypassed by a malicious client.
        // Server-side rate limiting is essential for actual security.
        function canCallWebhook(type) {
            const now = Date.now();
            const lastCall = type === 'video' ? webhookThrottleState.lastVideoCall : webhookThrottleState.lastImageCall;
            
            if (now - lastCall < WEBHOOK_THROTTLE_DURATION) {
                const remainingTime = Math.ceil((WEBHOOK_THROTTLE_DURATION - (now - lastCall)) / 1000);
                throw new Error(`Please wait ${remainingTime} seconds before generating another ${type}. This prevents duplicate requests.`);
            }
            
            return true;
        }

        // Update last webhook call timestamp
        function updateWebhookTimestamp(type) {
            const now = Date.now();
            if (type === 'video') {
                webhookThrottleState.lastVideoCall = now;
            } else {
                webhookThrottleState.lastImageCall = now;
            }
        }

        // Background Job Management System
        let serviceWorkerRegistration = null;

        // Helper function to sanitize HTML
        function sanitizeHTML(text) {
            const temp = document.createElement('div');
            temp.textContent = text;
            return temp.innerHTML;
        }

        const backgroundJobState = {
            activeJobs: new Map(),
            completedJobs: new Map()
        };

        // Persistent storage keys for background jobs
        const STORAGE_KEYS = {
            ACTIVE_JOBS: 'ai_media_gen_active_jobs',
            COMPLETED_JOBS: 'ai_media_gen_completed_jobs'
        };

        // Save active jobs to localStorage for persistence
        function saveJobStateToPersistentStorage() {
            try {
                const activeJobsData = Array.from(backgroundJobState.activeJobs.entries()).map(([id, job]) => [id, job]);
                const completedJobsData = Array.from(backgroundJobState.completedJobs.entries()).map(([id, job]) => [id, job]);
                
                localStorage.setItem(STORAGE_KEYS.ACTIVE_JOBS, JSON.stringify(activeJobsData));
                localStorage.setItem(STORAGE_KEYS.COMPLETED_JOBS, JSON.stringify(completedJobsData));
                console.log('Job state saved to persistent storage');
            } catch (error) {
                console.error('Failed to save job state to storage:', error);
            }
        }

        // Load active jobs from localStorage on startup
        function loadJobStateFromPersistentStorage() {
            try {
                const activeJobsData = localStorage.getItem(STORAGE_KEYS.ACTIVE_JOBS);
                const completedJobsData = localStorage.getItem(STORAGE_KEYS.COMPLETED_JOBS);
                
                if (activeJobsData) {
                    const activeJobs = JSON.parse(activeJobsData);
                    backgroundJobState.activeJobs = new Map(activeJobs);
                    console.log('Restored', activeJobs.length, 'active jobs from storage');
                }
                
                if (completedJobsData) {
                    const completedJobs = JSON.parse(completedJobsData);
                    backgroundJobState.completedJobs = new Map(completedJobs);
                    console.log('Restored', completedJobs.length, 'completed jobs from storage');
                }
                
                return backgroundJobState.activeJobs.size > 0;
            } catch (error) {
                console.error('Failed to load job state from storage:', error);
                return false;
            }
        }

        // Clean up completed jobs from storage (keep only recent ones)
        function cleanupJobStorage() {
            try {
                const now = Date.now();
                const maxAge = 24 * 60 * 60 * 1000; // 24 hours
                
                // Clean completed jobs older than 24 hours
                const completedJobs = Array.from(backgroundJobState.completedJobs.entries());
                const recentCompletedJobs = completedJobs.filter(([id, job]) => {
                    return (now - job.startedAt) < maxAge;
                });
                
                backgroundJobState.completedJobs = new Map(recentCompletedJobs);
                
                // Clean any orphaned active jobs older than 2 hours (likely failed)
                const activeJobs = Array.from(backgroundJobState.activeJobs.entries());
                const validActiveJobs = activeJobs.filter(([id, job]) => {
                    return (now - job.startedAt) < (2 * 60 * 60 * 1000);
                });
                
                backgroundJobState.activeJobs = new Map(validActiveJobs);
                
                saveJobStateToPersistentStorage();
                console.log('Cleaned up job storage');
            } catch (error) {
                console.error('Failed to cleanup job storage:', error);
            }
        }

        // Initialize service worker communication
        async function initServiceWorkerCommunication() {
            if ('serviceWorker' in navigator) {
                try {
                    // Load persistent job state first
                    const hasActiveJobs = loadJobStateFromPersistentStorage();
                    
                    serviceWorkerRegistration = await navigator.serviceWorker.ready;
                    console.log('Service worker ready for background jobs');
                    
                    // Listen for job status updates from service worker
                    navigator.serviceWorker.addEventListener('message', handleServiceWorkerMessage);
                    
                    // Clean up old job data
                    cleanupJobStorage();
                    
                    // Check for completed jobs on startup and sync with service worker
                    await checkBackgroundJobStatus();
                    
                    // If we have active jobs, make sure UI reflects this
                    if (hasActiveJobs) {
                        console.log('Restoring background job UI for', backgroundJobState.activeJobs.size, 'active jobs');
                        updateBackgroundJobsUI();
                    }
                    
                } catch (error) {
                    console.error('Failed to initialize service worker communication:', error);
                }
            }
        }

        // Handle messages from service worker
        function handleServiceWorkerMessage(event) {
            const { type, jobId, status, error } = event.data;
            
            if (type === 'JOB_STATUS_UPDATE') {
                console.log('Job status update:', jobId, status);
                
                if (status === 'completed') {
                    handleJobCompletion(jobId);
                } else if (status === 'failed') {
                    handleJobFailure(jobId, error);
                }
            }
        }

        // Send job to service worker for background processing
        async function sendJobToServiceWorker(jobData) {
            if (!serviceWorkerRegistration) {
                throw new Error('Service worker not available');
            }
            
            // Store job in local state
            backgroundJobState.activeJobs.set(jobData.id, {
                ...jobData,
                startedAt: Date.now(),
                status: 'pending'
            });
            
            // Save to persistent storage
            saveJobStateToPersistentStorage();
            
            // Send to service worker
            serviceWorkerRegistration.active.postMessage({
                type: 'START_BACKGROUND_JOB',
                jobData: jobData
            });
            
            console.log('Job sent to service worker:', jobData.id);
        }

        // Check background job status
        async function checkBackgroundJobStatus() {
            if (!serviceWorkerRegistration) return;
            
            return new Promise((resolve) => {
                const messageChannel = new MessageChannel();
                
                messageChannel.port1.onmessage = (event) => {
                    const { jobs } = event.data;
                    console.log('Background jobs status from service worker:', jobs);
                    
                    // Sync service worker jobs with local state
                    jobs.forEach(job => {
                        if (job.status === 'completed' && !backgroundJobState.completedJobs.has(job.id)) {
                            // Check if we have this job in our active jobs
                            if (backgroundJobState.activeJobs.has(job.id)) {
                                handleJobCompletion(job.id);
                            } else {
                                console.log('Found completed job not in local state:', job.id);
                                // Add to local state and handle completion
                                backgroundJobState.activeJobs.set(job.id, job);
                                handleJobCompletion(job.id);
                            }
                        } else if (job.status === 'pending' && !backgroundJobState.activeJobs.has(job.id)) {
                            // Service worker has pending job we don't know about
                            console.log('Found pending job not in local state:', job.id);
                            backgroundJobState.activeJobs.set(job.id, job);
                            saveJobStateToPersistentStorage();
                        }
                    });
                    
                    // Update UI to reflect current state
                    updateBackgroundJobsUI();
                    
                    resolve(jobs);
                };
                
                serviceWorkerRegistration.active.postMessage(
                    { type: 'CHECK_JOB_STATUS' },
                    [messageChannel.port2]
                );
            });
        }

        // Handle job completion
        async function handleJobCompletion(jobId) {
            console.log('Handling job completion:', jobId);
            
            const job = backgroundJobState.activeJobs.get(jobId);
            if (!job) {
                console.log('Job not found in active jobs, checking service worker...');
                return;
            }
            
            // Move to completed jobs
            backgroundJobState.completedJobs.set(jobId, job);
            backgroundJobState.activeJobs.delete(jobId);
            
            // Save updated state to persistent storage
            saveJobStateToPersistentStorage();
            
            // Get result from service worker's IndexedDB
            await retrieveAndDisplayJobResult(job);
        }

        // Handle job failure
        function handleJobFailure(jobId, error) {
            console.log('Handling job failure:', jobId, error);
            
            const job = backgroundJobState.activeJobs.get(jobId);
            if (job) {
                backgroundJobState.activeJobs.delete(jobId);
                
                // Save updated state to persistent storage
                saveJobStateToPersistentStorage();
                
                // Show error message
                const errorElement = document.getElementById(job.type + 'ErrorMessage');
                const errorText = document.getElementById(job.type + 'ErrorText');
                
                if (errorElement && errorText) {
                    errorText.textContent = error || 'Background generation failed. Please try again.';
                    errorElement.classList.add('show');
                }
                
                // Reset UI
                resetJobUI(job.type);
            }
        }

        // Retrieve and display job result
        async function retrieveAndDisplayJobResult(job) {
            try {
                // Access service worker's IndexedDB to get the result
                const db = await openBackgroundJobDB();
                const result = await getJobResult(db, job.id);
                
                if (result && result.resultBlob) {
                    const dataUrl = URL.createObjectURL(result.resultBlob);
                    
                    if (job.type === 'video') {
                        displayVideoResult(dataUrl, job);
                    } else if (job.type === 'image') {
                        displayImageResult(dataUrl, job);
                    }
                    
                    // Save to gallery
                    await saveToGallery(job.type, job.prompt, dataUrl, job.settings);
                    
                    // Auto-update gallery if user is currently viewing it
                    refreshGalleryIfVisible();
                    
                    // Show success message
                    const successElement = document.getElementById(job.type + 'SuccessMessage');
                    if (successElement) {
                        successElement.classList.add('show');
                    }
                }
                
            } catch (error) {
                console.error('Error retrieving job result:', error);
                handleJobFailure(job.id, 'Failed to retrieve generated content');
            }
        }

        // Check if gallery tab is currently visible and refresh it
        function refreshGalleryIfVisible() {
            const galleryTab = document.getElementById('gallery-tab');
            if (galleryTab && galleryTab.classList.contains('active')) {
                console.log('Gallery is visible, refreshing...');
                loadGallery();
            }
        }

        // Get currently active tab
        function getCurrentActiveTab() {
            const activeTab = document.querySelector('.tab-content.active');
            if (activeTab) {
                return activeTab.id.replace('-tab', '');
            }
            return null;
        }

        // Open background job database (same as service worker)
        function openBackgroundJobDB() {
            return new Promise((resolve, reject) => {
                const request = indexedDB.open('BackgroundJobsDB', 1);
                request.onerror = () => reject(request.error);
                request.onsuccess = () => resolve(request.result);
            });
        }

        // Get job result from database
        function getJobResult(db, jobId) {
            return new Promise((resolve, reject) => {
                const transaction = db.transaction(['jobs'], 'readonly');
                const store = transaction.objectStore('jobs');
                const request = store.get(jobId);
                
                request.onsuccess = () => resolve(request.result);
                request.onerror = () => reject(request.error);
            });
        }

        // Display video result
        function displayVideoResult(dataUrl, job) {
            const videoContainer = document.getElementById('videoContainer');
            const videoPlayer = document.getElementById('videoPlayer');
            const actionButtons = document.getElementById('videoActionButtons');
            
            videoPlayer.src = dataUrl;
            videoContainer.classList.add('show');
            actionButtons.classList.add('show');
            
            resetJobUI('video');
        }

        // Display image result
        function displayImageResult(dataUrl, job) {
            const imageContainer = document.getElementById('imageContainer');
            const generatedImage = document.getElementById('generatedImage');
            const actionButtons = document.getElementById('imageActionButtons');
            
            generatedImage.src = dataUrl;
            imageContainer.classList.add('show');
            actionButtons.classList.add('show');
            
            resetJobUI('image');
        }

        // Reset job UI elements
        function resetJobUI(type) {
            const submitBtn = document.getElementById(type + 'SubmitBtn');
            const loading = document.getElementById(type + 'Loading');
            
            if (submitBtn) {
                submitBtn.disabled = false;
                submitBtn.textContent = type === 'video' ? 'Generate Video' : 'Generate Image';
            }
            
            if (loading) {
                loading.classList.remove('show');
            }
        }

        // Update background jobs UI
        function updateBackgroundJobsUI() {
            const statusElement = document.getElementById('backgroundJobsStatus');
            const listElement = document.getElementById('backgroundJobsList');
            
            const activeJobs = Array.from(backgroundJobState.activeJobs.values());
            
            if (activeJobs.length === 0) {
                statusElement.style.display = 'none';
                return;
            }
            
            statusElement.style.display = 'block';
            
            listElement.innerHTML = activeJobs.map(job => {
                const timeElapsed = Math.floor((Date.now() - job.startedAt) / 1000);
                const minutes = Math.floor(timeElapsed / 60);
                const seconds = timeElapsed % 60;
                const timeText = minutes > 0 ? `${minutes}m ${seconds}s` : `${seconds}s`;
                
                return `
                    <div class="background-job-item">
                        <div class="background-job-icon">${job.type === 'video' ? '🎬' : '🎨'}</div>
                        <div class="background-job-content">
                            <div class="background-job-type">${job.type} Generation</div>
                            <div class="background-job-prompt">${job.prompt}</div>
                            <div class="background-job-time">Running for ${timeText}</div>
                        </div>
                        <div class="background-job-spinner"></div>
                    </div>
                `;
            }).join('');
        }

        // Enhanced job management with better UI sync
        const originalSendJobToServiceWorker = sendJobToServiceWorker;
        sendJobToServiceWorker = async function(jobData) {
            await originalSendJobToServiceWorker(jobData);
            updateBackgroundJobsUI();
            
            // Also refresh gallery UI if we're on gallery tab to show background jobs
            if (getCurrentActiveTab() === 'gallery') {
                updateBackgroundJobsUI();
            }
        };

        const originalHandleJobCompletion = handleJobCompletion;
        handleJobCompletion = async function(jobId) {
            await originalHandleJobCompletion(jobId);
            updateBackgroundJobsUI();
            
            // Add a small delay to ensure gallery refresh happens after save
            setTimeout(() => {
                refreshGalleryIfVisible();
            }, 100);
        };

        const originalHandleJobFailure = handleJobFailure;
        handleJobFailure = function(jobId, error) {
            originalHandleJobFailure(jobId, error);
            updateBackgroundJobsUI();
        };

        // Document ready handler
        document.addEventListener('DOMContentLoaded', function() {
            setupEventListeners();
            initServiceWorkerCommunication();
            
            // Fallback: Set up tab listeners again after a short delay
            setTimeout(() => {
                console.log('Setting up fallback tab listeners');
                document.querySelectorAll('.tab-button').forEach(button => {
                    if (!button.hasAttribute('data-listener-added')) {
                        button.addEventListener('click', function(e) {
                            e.preventDefault();
                            e.stopPropagation();
                            const tabName = this.dataset.tab;
                            console.log('Fallback tab clicked:', tabName);
                            switchTab(tabName);
                        });
                        button.setAttribute('data-listener-added', 'true');
                    }
                });
            }, 100);
            
            // Update background jobs UI every 5 seconds
            setInterval(updateBackgroundJobsUI, 5000);
            
            // Periodic sync with service worker every 10 seconds when there are active jobs
            setInterval(async () => {
                if (backgroundJobState.activeJobs.size > 0 && serviceWorkerRegistration) {
                    console.log('Periodic sync: checking background job status');
                    await checkBackgroundJobStatus();
                }
            }, 10000);
        });

        // Handle app focus/resume to check for completed jobs
        window.addEventListener('focus', function() {
            console.log('App focused, checking for completed jobs...');
            if (serviceWorkerRegistration) {
                checkBackgroundJobStatus();
                
                // Also refresh gallery if visible
                refreshGalleryIfVisible();
            }
        });

        // Handle page visibility change (mobile background/foreground)
        document.addEventListener('visibilitychange', function() {
            if (!document.hidden) {
                console.log('App became visible, checking for completed jobs...');
                if (serviceWorkerRegistration) {
                    checkBackgroundJobStatus();
                    
                    // Also refresh gallery if visible
                    setTimeout(() => {
                        refreshGalleryIfVisible();
                    }, 500);
                }
            }
        });

        // Improve Prompt Function
        async function improvePrompt() {
            const promptTextarea = document.getElementById('imagePrompt');
            const improveBtn = document.getElementById('improvePromptBtn');
            const inputImageField = document.getElementById('inputImage');
            const currentPrompt = promptTextarea.value.trim();
            
            if (!currentPrompt) {
                alert('Please enter a prompt first before improving it.');
                return;
            }
            
            // Check if an input image is selected
            const hasInputImage = inputImageField.files && inputImageField.files.length > 0;
            
            // Disable button and show loading state
            improveBtn.disabled = true;
            improveBtn.textContent = '🔄 Improving...';
            
            try {
                // Prepare the webhook URL with image flag
                const webhookUrl = `https://n8n.xtend3d.com/webhook/ai-prompt-magic?image=${hasInputImage}`;
                
                const response = await fetch(webhookUrl, {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'text/plain',
                        'azure': 'xtend3d'
                    },
                    body: currentPrompt
                });
                
                if (!response.ok) {
                    throw new Error(`HTTP error! status: ${response.status}`);
                }
                
                const improvedPrompt = await response.text();
                
                // Update the textarea with improved prompt
                promptTextarea.value = improvedPrompt;
                
                // Expand textarea height for better readability
                promptTextarea.style.minHeight = '120px';
                
                // Optional: Add visual feedback
                promptTextarea.style.border = '2px solid #38a169';
                setTimeout(() => {
                    promptTextarea.style.border = '';
                }, 2000);
                
            } catch (error) {
                console.error('Error improving prompt:', error);
                alert('Failed to improve prompt. Please try again.');
            } finally {
                // Re-enable button
                improveBtn.disabled = false;
                improveBtn.textContent = '🪄 Improve Prompt';
            }
        }

        // Improve Video Prompt Function
        async function improveVideoPrompt() {
            const promptTextarea = document.getElementById('videoDescription');
            const improveBtn = document.getElementById('improveVideoPromptBtn');
            const currentPrompt = promptTextarea.value.trim();
            
            if (!currentPrompt) {
                alert('Please enter a video description first before improving it.');
                return;
            }
            
            // Disable button and show loading state
            improveBtn.disabled = true;
            improveBtn.textContent = '🔄 Improving...';
            
            try {
                // Prepare the webhook URL with video flag
                const webhookUrl = 'https://n8n.xtend3d.com/webhook/ai-prompt-magic?image=video';
                
                const response = await fetch(webhookUrl, {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'text/plain',
                        'azure': 'xtend3d'
                    },
                    body: currentPrompt
                });
                
                if (!response.ok) {
                    throw new Error(`HTTP error! status: ${response.status}`);
                }
                
                const improvedPrompt = await response.text();
                
                // Update the textarea with improved prompt
                promptTextarea.value = improvedPrompt;
                
                // Expand textarea height for better readability
                promptTextarea.style.minHeight = '120px';
                
                // Optional: Add visual feedback
                promptTextarea.style.border = '2px solid #38a169';
                setTimeout(() => {
                    promptTextarea.style.border = '';
                }, 2000);
                
            } catch (error) {
                console.error('Error improving video prompt:', error);
                alert('Failed to improve video prompt. Please try again.');
            } finally {
                // Re-enable button
                improveBtn.disabled = false;
                improveBtn.textContent = '🪄 Improve Prompt';
            }
        }

        // Show image settings
        function showImageSettings() {
            document.getElementById('imageForm').classList.remove('settings-collapsed');
            document.getElementById('imageForm').classList.add('settings-expanded');
            document.getElementById('imageActionButtons').classList.remove('show');
            document.getElementById('imageContainer').classList.remove('show');
            document.getElementById('imageSuccessMessage').classList.remove('show');
        }

        // Download generated image
        function downloadImage() {
            const link = document.createElement('a');
            link.href = document.getElementById('generatedImage').src;
            link.download = `ai-image-${Date.now()}.png`;
            document.body.appendChild(link);
            link.click();
            document.body.removeChild(link);
        }

        // Show video settings
        function showVideoSettings() {
            document.getElementById('videoForm').classList.remove('settings-collapsed');
            document.getElementById('videoForm').classList.add('settings-expanded');
            document.getElementById('videoActionButtons').classList.remove('show');
            document.getElementById('videoContainer').classList.remove('show');
            document.getElementById('videoSuccessMessage').classList.remove('show');
        }

        // Download generated video
        function downloadVideo() {
            const link = document.createElement('a');
            link.href = document.getElementById('videoPlayer').src;
            link.download = `ai-video-${Date.now()}.mp4`;
            document.body.appendChild(link);
            link.click();
            document.body.removeChild(link);
        }

        // Gallery Database Helper Functions
        function openGalleryDB() {
            return new Promise((resolve, reject) => {
                const request = indexedDB.open('GalleryDB', 1);
                request.onerror = () => reject(request.error);
                request.onsuccess = () => resolve(request.result);
                request.onupgradeneeded = (event) => {
                    const db = event.target.result;
                    if (!db.objectStoreNames.contains('gallery')) {
                        db.createObjectStore('gallery', { keyPath: 'id' });
                    }
                };
            });
        }

        function deleteFromGalleryDB(db, id) {
            return new Promise((resolve, reject) => {
                const transaction = db.transaction(['gallery'], 'readwrite');
                const store = transaction.objectStore('gallery');
                const request = store.delete(id);
                request.onsuccess = () => resolve();
                request.onerror = () => reject(request.error);
            });
        }

        function clearGalleryDB(db) {
            return new Promise((resolve, reject) => {
                const transaction = db.transaction(['gallery'], 'readwrite');
                const store = transaction.objectStore('gallery');
                const request = store.clear();
                request.onsuccess = () => resolve();
                request.onerror = () => reject(request.error);
            });
        }

        // Save generated content to gallery
        async function saveToGallery(type, prompt, dataUrl, settings) {
            try {
                // Convert blob url to base64 to store in IndexedDB
                const response = await fetch(dataUrl);
                const blob = await response.blob();
                const reader = new FileReader();
                reader.readAsDataURL(blob);
                reader.onloadend = async () => {
                    const base64data = reader.result;

                    const db = await openGalleryDB();
                    const transaction = db.transaction(['gallery'], 'readwrite');
                    const store = transaction.objectStore('gallery');

                    const id = `${type}_${Date.now()}`;
                    const item = {
                        id,
                        type,
                        prompt,
                        dataUrl: base64data,
                        settings,
                        createdAt: new Date()
                    };

                    await new Promise((resolve, reject) => {
                        const request = store.put(item);
                        request.onsuccess = () => resolve();
                        request.onerror = () => reject(request.error);
                    });

                    console.log('Saved to gallery:', id);
                };
            } catch (error) {
                console.error('Error saving to gallery:', error);
            }
        }

        // Load gallery items from IndexedDB
        async function loadGallery() {
            const galleryContent = document.getElementById('galleryContent');
            galleryContent.innerHTML = '<div class="loading-spinner"></div>'; // Show loader

            try {
                const db = await openGalleryDB();
                const transaction = db.transaction(['gallery'], 'readonly');
                const store = transaction.objectStore('gallery');
                const request = store.getAll();

                request.onsuccess = () => {
                    const items = request.result.sort((a, b) => new Date(b.createdAt) - new Date(a.createdAt));
                    
                    if (items.length === 0) {
                        galleryContent.innerHTML = `
                            <div class="gallery-empty">
                                <div class="gallery-empty-icon">🖼️</div>
                                <div>Your generated images and videos will appear here.</div>
                            </div>
                        `;
                        return;
                    }

                    const grid = document.createElement('div');
                    grid.className = 'gallery-grid';

                    items.slice(0, 50).forEach(item => {
                        const itemElement = document.createElement('div');
                        itemElement.className = 'gallery-item';
                        itemElement.addEventListener('click', () => openModal(item));

                        const mediaElement = item.type === 'video'
                            ? document.createElement('video')
                            : document.createElement('img');
                        
                        mediaElement.src = item.dataUrl;
                        mediaElement.className = 'gallery-item-media';
                        if (item.type === 'video') {
                            mediaElement.muted = true;
                            mediaElement.playsInline = true;
                            mediaElement.autoplay = true;
                            mediaElement.loop = true;
                        }


                        const typeIcon = document.createElement('div');
                        typeIcon.className = 'gallery-item-type';
                        typeIcon.textContent = item.type === 'video' ? '🎬' : '🎨';

                        const deleteBtn = document.createElement('button');
                        deleteBtn.className = 'gallery-item-delete';
                        deleteBtn.innerHTML = '&times;';
                        deleteBtn.setAttribute('data-action', 'delete-gallery-item');
                        deleteBtn.setAttribute('data-item-id', item.id);

                        itemElement.appendChild(mediaElement);
                        itemElement.appendChild(typeIcon);
                        itemElement.appendChild(deleteBtn);
                        grid.appendChild(itemElement);
                    });

                    galleryContent.innerHTML = '';
                    galleryContent.appendChild(grid);
                };

                request.onerror = (event) => {
                    throw new Error('Error fetching gallery items: ' + event.target.error);
                };

            } catch (error) {
                console.error('Error loading gallery:', error);
                galleryContent.innerHTML = `
                    <div class="gallery-empty">
                        <div class="gallery-empty-icon">⚠️</div>
                        <div>Could not load the gallery.</div>
                        <div style="font-size: 12px; color: #a0aec0;">${error.message}</div>
                    </div>
                `;
            }
        }

        // Open modal for full-size viewing
        function openModal(item) {
            const modal = document.getElementById('mediaModal');
            const modalImage = document.getElementById('modalImage');
            const modalVideo = document.getElementById('modalVideo');
            const modalPrompt = document.getElementById('modalPrompt');
            const modalSettings = document.getElementById('modalSettings');
            const modalDate = document.getElementById('modalDate');

            modalPrompt.textContent = item.prompt;
            modalSettings.innerHTML = Object.entries(item.settings)
                .map(([key, value]) => `<span><strong>${key.replace(/([A-Z])/g, ' $1')}:</strong> ${value}</span>`)
                .join('');
            modalDate.textContent = new Date(item.createdAt).toLocaleString();

            if (item.type === 'image') {
                modalImage.src = item.dataUrl;
                modalImage.style.display = 'block';
                modalVideo.style.display = 'none';
                modalVideo.src = '';
            } else {
                modalVideo.src = item.dataUrl;
                modalVideo.style.display = 'block';
                modalImage.style.display = 'none';
                modalImage.src = '';
            }

            modal.classList.add('show');
        }

        // Close modal
        function closeModal() {
            const modal = document.getElementById('mediaModal');
            modal.classList.remove('show');
            // Stop video playback
            document.getElementById('modalVideo').pause();
        }

        // Clear all browser data
        async function clearAllBrowserData() {
            if (!confirm('Are you sure you want to clear ALL browser data? This will remove all generated content, settings, and active jobs. This action cannot be undone.')) {
                return;
            }

            try {
                console.log('Clearing all browser data...');

                // 1. Unregister all service workers
                if ('serviceWorker' in navigator) {
                    const registrations = await navigator.serviceWorker.getRegistrations();
                    for (const registration of registrations) {
                        await registration.unregister();
                        console.log('Service worker unregistered');
                    }
                }

                // 2. Clear all caches
                if ('caches' in window) {
                    const keys = await caches.keys();
                    await Promise.all(keys.map(key => caches.delete(key)));
                    console.log('Caches cleared');
                }

                // 3. Delete all IndexedDB databases
                if ('indexedDB' in window && typeof indexedDB.databases === 'function') {
                    const dbs = await indexedDB.databases();
                    await Promise.all(dbs.map(db => new Promise((resolve, reject) => {
                        console.log(`Deleting IndexedDB: ${db.name}`);
                        const deleteRequest = indexedDB.deleteDatabase(db.name);
                        deleteRequest.onsuccess = () => {
                            console.log(`Deleted ${db.name}`);
                            resolve();
                        };
                        deleteRequest.onerror = (event) => {
                            console.error(`Error deleting ${db.name}`, event.target.error);
                            reject(deleteRequest.error);
                        };
                        deleteRequest.onblocked = () => {
                            console.warn(`Deletion of ${db.name} is blocked.`);
                            reject(new Error(`Deletion of ${db.name} is blocked.`));
                        };
                    })));
                    console.log('IndexedDBs cleared');
                } else {
                    // Fallback for browsers that don't support indexedDB.databases()
                    // Manually delete known databases
                    await new Promise((resolve, reject) => {
                        const req = indexedDB.deleteDatabase('BackgroundJobsDB');
                        req.onsuccess = resolve;
                        req.onerror = reject;
                    });
                     await new Promise((resolve, reject) => {
                        const req = indexedDB.deleteDatabase('GalleryDB');
                        req.onsuccess = resolve;
                        req.onerror = reject;
                    });
                    console.log('Known IndexedDBs cleared');
                }


                // 4. Clear localStorage and sessionStorage
                localStorage.clear();
                sessionStorage.clear();
                console.log('Local and session storage cleared');

                alert('All browser data has been cleared. The application will now reload.');
                window.location.reload();

            } catch (error) {
                console.error('Error clearing browser data:', error);
                alert(`An error occurred while clearing data: ${error.message}. You may need to clear data manually in your browser settings.`);
            }
        }

        // Delete a single gallery item
        async function deleteGalleryItem(itemId, event) {
            event.stopPropagation(); // Prevent modal from opening

            if (!confirm('Are you sure you want to delete this item?')) {
                return;
            }

            try {
                const db = await openGalleryDB();
                await deleteFromGalleryDB(db, itemId);

                // Remove from UI
                const itemElement = event.target.closest('.gallery-item');
                if (itemElement) {
                    itemElement.remove();
                }

                // Check if gallery is now empty
                const galleryGrid = document.querySelector('.gallery-grid');
                if (galleryGrid && galleryGrid.children.length === 0) {
                    loadGallery(); // Reload to show empty message
                }

            } catch (error) {
                console.error('Error deleting gallery item:', error);
                alert('Failed to delete item. Please try again.');
            }
        }

        // Clear all gallery items
        async function clearAllGallery() {
            if (!confirm('Are you sure you want to clear the entire gallery? This cannot be undone.')) {
                return;
            }

            try {
                const db = await openGalleryDB();
                await clearGalleryDB(db);
                loadGallery(); // Reload to show empty message
            } catch (error) {
                console.error('Error clearing gallery:', error);
                alert('Failed to clear gallery. Please try again.');
            }
        }

        // Setup all event listeners
        function setupEventListeners() {
            // Tab navigation - more robust event handling
            document.querySelectorAll('.tab-button').forEach(button => {
                button.addEventListener('click', function(e) {
                    e.preventDefault();
                    e.stopPropagation();
                    const tabName = this.dataset.tab;
                    console.log('Tab clicked:', tabName); // Debug log
                    switchTab(tabName);
                });
                button.setAttribute('data-listener-added', 'true');
            });

            // Improve Prompt buttons
            document.getElementById('improvePromptBtn').addEventListener('click', improvePrompt);
            document.getElementById('improveVideoPromptBtn').addEventListener('click', improveVideoPrompt);

            // Action buttons
            document.addEventListener('click', function(e) {
                const action = e.target.getAttribute('data-action');
                if (!action) return;

                switch(action) {
                    case 'show-image-settings':
                        showImageSettings();
                        break;
                    case 'download-image':
                        downloadImage();
                        break;
                    case 'show-video-settings':
                        showVideoSettings();
                        break;
                    case 'download-video':
                        downloadVideo();
                        break;
                    case 'clear-gallery':
                        clearAllGallery();
                        break;
                    case 'clear-browser-data':
                        clearAllBrowserData();
                        break;
                    case 'close-modal':
                        closeModal();
                        break;
                    case 'delete-gallery-item':
                        const itemId = e.target.getAttribute('data-item-id');
                        deleteGalleryItem(itemId, e);
                        break;
                }
            });
        }

        // Tab switching functionality
        function switchTab(tabName) {
            console.log('Switching to tab:', tabName); // Debug log
            
            // Hide all tab contents
            document.querySelectorAll('.tab-content').forEach(tab => {
                tab.classList.remove('active');
            });
            
            // Remove active class from all tab buttons
            document.querySelectorAll('.tab-button').forEach(btn => {
                btn.classList.remove('active');
            });
            
            // Show selected tab content
            const targetTab = document.getElementById(tabName + '-tab');
            if (targetTab) {
                targetTab.classList.add('active');
                console.log('Tab content activated:', tabName + '-tab'); // Debug log
            } else {
                console.error('Tab content not found:', tabName + '-tab');
            }
            
            // Add active class to the correct button
            const buttonToActivate = document.querySelector(`.tab-button[data-tab="${tabName}"]`);
            if (buttonToActivate) {
                buttonToActivate.classList.add('active');
                console.log('Tab button activated:', tabName); // Debug log
            } else {
                console.error('Tab button not found:', tabName);
            }
            
            // Load gallery if switching to gallery tab
            if (tabName === 'gallery') {
                loadGallery();
                updateBackgroundJobsUI();
            }
        }

        // File upload label update
        document.getElementById('inputImage').addEventListener('change', function(e) {
            const label = document.getElementById('imageUploadLabel');
            if (e.target.files.length > 0) {
                label.textContent = `📁 ${e.target.files[0].name}`;
                label.classList.add('has-file');
            } else {
                label.textContent = '📁 Choose an image file (optional)';
                label.classList.remove('has-file');
            }
        });

        // Video Form Handler (Background Processing)
        document.getElementById('videoForm').addEventListener('submit', async function(e) {
            e.preventDefault();

            const submitBtn = document.getElementById('videoSubmitBtn');
            const loading = document.getElementById('videoLoading');
            const videoContainer = document.getElementById('videoContainer');
            const successMessage = document.getElementById('videoSuccessMessage');
            const errorMessage = document.getElementById('videoErrorMessage');
            const errorText = document.getElementById('videoErrorText');
            
            try {
                // Check throttling before any UI changes
                canCallWebhook('video');
                
                // Reset UI State and collapse settings
                videoContainer.classList.remove('show');
                successMessage.classList.remove('show');
                errorMessage.classList.remove('show');
                submitBtn.disabled = true;
                submitBtn.textContent = 'Generating in Background...';
                loading.classList.add('show');
                
                // Collapse the form settings
                document.getElementById('videoForm').classList.remove('settings-expanded');
                document.getElementById('videoForm').classList.add('settings-collapsed');

                // Update throttle timestamp immediately after UI changes
                updateWebhookTimestamp('video');
            } catch (throttleError) {
                // Handle throttling error without changing UI state
                errorText.textContent = throttleError.message;
                errorMessage.classList.add('show');
                return;
            }

            try {
                // Prepare form data for service worker (convert to serializable format)
                const formFields = {
                    prompt: document.getElementById('videoDescription').value,
                    duration: document.querySelector('input[name="duration"]:checked').value,
                    aspect_ratio: document.querySelector('input[name="aspectRatio"]:checked').value,
                    format: document.querySelector('input[name="format"]:checked').value,
                    n: '1'
                };

                // Create job data for service worker
                const jobData = {
                    id: 'video_' + Date.now() + '_' + Math.random().toString(36).substr(2, 9),
                    type: 'video',
                    webhookUrl: 'https://n8n.xtend3d.com/webhook/sora-video-1',
                    headers: {
                        'azure': 'xtend3d',
                        'X-Device-Fingerprint': generateDeviceFingerprint(),
                        'X-Request-Timestamp': Date.now().toString()
                    },
                    formFields: formFields,
                    prompt: document.getElementById('videoDescription').value,
                    settings: {
                        duration: document.querySelector('input[name="duration"]:checked').value,
                        aspectRatio: document.querySelector('input[name="aspectRatio"]:checked').value,
                        format: document.querySelector('input[name="format"]:checked').value
                    }
                };

                console.log('Sending video job to service worker:', jobData.id);

                // Send to service worker
                await sendJobToServiceWorker(jobData);
                
                // Update loading text to show background processing
                const loadingText = document.querySelector('#videoLoading .loading-text');
                if (loadingText) {
                    loadingText.textContent = 'Generating in background...';
                }

            } catch (error) {
                console.error('Failed to start background video job:', error);
                errorText.textContent = error.message || 'Failed to start background generation. Please try again.';
                errorMessage.classList.add('show');
                
                // Reset UI on error
                submitBtn.disabled = false;
                submitBtn.textContent = 'Generate Video';
                loading.classList.remove('show');
            }
        });

        // Image Form Handler (Background Processing)
        document.getElementById('imageForm').addEventListener('submit', async function(e) {
            e.preventDefault();

            const submitBtn = document.getElementById('imageSubmitBtn');
            const loading = document.getElementById('imageLoading');
            const imageContainer = document.getElementById('imageContainer');
            const successMessage = document.getElementById('imageSuccessMessage');
            const errorMessage = document.getElementById('imageErrorMessage');
            const errorText = document.getElementById('imageErrorText');
            
            try {
                // Check throttling before any UI changes
                canCallWebhook('image');
                
                // Reset UI State and collapse settings
                imageContainer.classList.remove('show');
                successMessage.classList.remove('show');
                errorMessage.classList.remove('show');
                submitBtn.disabled = true;
                submitBtn.textContent = 'Generating in Background...';
                loading.classList.add('show');
                
                // Collapse the form settings
                document.getElementById('imageForm').classList.remove('settings-expanded');
                document.getElementById('imageForm').classList.add('settings-collapsed');

                // Update throttle timestamp immediately after UI changes
                updateWebhookTimestamp('image');
            } catch (throttleError) {
                // Handle throttling error without changing UI state
                errorText.textContent = throttleError.message;
                errorMessage.classList.add('show');
                return;
            }

            try {
                // Prepare form data for service worker (convert to serializable format)
                const formFields = {
                    prompt: document.getElementById('imagePrompt').value,
                    size: document.querySelector('input[name="size"]:checked').value,
                    quality: document.querySelector('input[name="quality"]:checked').value,
                    output_format: document.querySelector('input[name="outputFormat"]:checked').value,
                    n: '1'
                };
                
                // Handle optional input image
                const inputImage = document.getElementById('inputImage').files[0];
                let imageArrayBuffer = null;
                let imageFileName = null;
                let imageType = null;
                
                if (inputImage) {
                    imageArrayBuffer = await inputImage.arrayBuffer();
                    imageFileName = inputImage.name;
                    imageType = inputImage.type;
                }

                // Create job data for service worker
                const jobData = {
                    id: 'image_' + Date.now() + '_' + Math.random().toString(36).substr(2, 9),
                    type: 'image',
                    webhookUrl: 'https://n8n.xtend3d.com/webhook/gpt-image-1',
                    headers: {
                        'azure': 'xtend3d',
                        'X-Device-Fingerprint': generateDeviceFingerprint(),
                        'X-Request-Timestamp': Date.now().toString()
                    },
                    formFields: formFields,
                    imageData: imageArrayBuffer ? {
                        buffer: imageArrayBuffer,
                        fileName: imageFileName,
                        type: imageType
                    } : null,
                    prompt: document.getElementById('imagePrompt').value,
                    settings: {
                        size: document.querySelector('input[name="size"]:checked').value,
                        quality: document.querySelector('input[name="quality"]:checked').value,
                        outputFormat: document.querySelector('input[name="outputFormat"]:checked').value,
                        hasInputImage: !!inputImage
                    }
                };

                console.log('Sending image job to service worker:', jobData.id);

                // Send to service worker
                await sendJobToServiceWorker(jobData);
                
                // Update loading text to show background processing
                const loadingText = document.querySelector('#imageLoading .loading-text');
                if (loadingText) {
                    loadingText.textContent = 'Generating in background...';
                }

            } catch (error) {
                console.error('Failed to start background image job:', error);
                errorText.textContent = error.message || 'Failed to start background generation. Please try again.';
                errorMessage.classList.add('show');
                
                // Reset UI on error
                submitBtn.disabled = false;
                submitBtn.textContent = 'Generate Image';
                loading.classList.remove('show');
            }
        });

        // Action button functions
        function showImageSettings() {
            document.getElementById('imageForm').classList.remove('settings-collapsed');
            document.getElementById('imageForm').classList.add('settings-expanded');
            document.getElementById('imageActionButtons').classList.remove('show');
            document.getElementById('imageContainer').classList.remove('show');
            document.getElementById('imageSuccessMessage').classList.remove('show');
        }

        function showVideoSettings() {
            document.getElementById('videoForm').classList.remove('settings-collapsed');
            document.getElementById('videoForm').classList.add('settings-expanded');
            document.getElementById('videoActionButtons').classList.remove('show');
            document.getElementById('videoContainer').classList.remove('show');
            document.getElementById('videoSuccessMessage').classList.remove('show');
        }

        function downloadImage() {
            const img = document.getElementById('generatedImage');
            const canvas = document.createElement('canvas');
            const ctx = canvas.getContext('2d');
            
            canvas.width = img.naturalWidth;
            canvas.height = img.naturalHeight;
            ctx.drawImage(img, 0, 0);
            
            canvas.toBlob(function(blob) {
                const url = URL.createObjectURL(blob);
                const a = document.createElement('a');
                a.href = url;
                a.download = 'generated-image.png';
                document.body.appendChild(a);
                a.click();
                document.body.removeChild(a);
                URL.revokeObjectURL(url);
            });
        }

        function downloadVideo() {
            const video = document.getElementById('videoPlayer');
            const url = video.src;
            const a = document.createElement('a');
            a.href = url;
            a.download = 'generated-video.mp4';
            document.body.appendChild(a);
            a.click();
            document.body.removeChild(a);
        }

        // IndexedDB Gallery Functions
        const DB_NAME = 'AIGalleryDB';
        const DB_VERSION = 1;
        const STORE_NAME = 'galleryItems';
        const MAX_GALLERY_ITEMS = 50;
        
        function initDB() {
            return new Promise((resolve, reject) => {
                const request = indexedDB.open(DB_NAME, DB_VERSION);
                
                request.onerror = () => reject(request.error);
                request.onsuccess = () => resolve(request.result);
                
                request.onupgradeneeded = (event) => {
                    const db = event.target.result;
                    if (!db.objectStoreNames.contains(STORE_NAME)) {
                        const store = db.createObjectStore(STORE_NAME, { keyPath: 'id' });
                        store.createIndex('createdAt', 'createdAt', { unique: false });
                    }
                };
            });
        }
        
        async function saveToGallery(type, prompt, dataUrl, settings) {
            console.log('Saving to gallery:', type, prompt);
            try {
                // Convert blob URL to blob for IndexedDB storage
                const response = await fetch(dataUrl);
                if (!response.ok) {
                    throw new Error('Failed to fetch blob for gallery save');
                }
                const blob = await response.blob();
                
                const galleryItem = {
                    id: Date.now().toString(),
                    type: type,
                    prompt: prompt,
                    data: blob,
                    settings: settings,
                    createdAt: new Date().toISOString()
                };
                
                const db = await initDB();
                const transaction = db.transaction([STORE_NAME], 'readwrite');
                const store = transaction.objectStore(STORE_NAME);
                
                // Add new item
                await new Promise((resolve, reject) => {
                    const request = store.add(galleryItem);
                    request.onsuccess = () => resolve();
                    request.onerror = () => reject(request.error);
                });
                
                // Get all items to check count and trim if necessary
                const allItems = await new Promise((resolve, reject) => {
                    const request = store.index('createdAt').getAll();
                    request.onsuccess = () => resolve(request.result);
                    request.onerror = () => reject(request.error);
                });
                
                // Sort by creation date (newest first) and trim if over limit
                allItems.sort((a, b) => new Date(b.createdAt) - new Date(a.createdAt));
                
                if (allItems.length > MAX_GALLERY_ITEMS) {
                    const itemsToDelete = allItems.slice(MAX_GALLERY_ITEMS);
                    for (const item of itemsToDelete) {
                        await new Promise((resolve, reject) => {
                            const deleteRequest = store.delete(item.id);
                            deleteRequest.onsuccess = () => resolve();
                            deleteRequest.onerror = () => reject(deleteRequest.error);
                        });
                    }
                    console.log('Gallery trimmed to', MAX_GALLERY_ITEMS, 'items');
                }
                
                console.log('Successfully saved to gallery. Total items:', Math.min(allItems.length, MAX_GALLERY_ITEMS));
                
            } catch (error) {
                console.error('Error saving to gallery:', error);
                alert('Error saving to gallery: ' + error.message);
            }
        }

        async function loadGallery() {
            const galleryContent = document.getElementById('galleryContent');
            
            try {
                const db = await initDB();
                const transaction = db.transaction([STORE_NAME], 'readonly');
                const store = transaction.objectStore(STORE_NAME);
                
                const items = await new Promise((resolve, reject) => {
                    const request = store.index('createdAt').getAll();
                    request.onsuccess = () => resolve(request.result);
                    request.onerror = () => reject(request.error);
                });
                
                // Sort by creation date (newest first)
                items.sort((a, b) => new Date(b.createdAt) - new Date(a.createdAt));
                
                if (items.length === 0) {
                    galleryContent.innerHTML = `
                        <div class="gallery-empty">
                            <div class="gallery-empty-icon">🖼️</div>
                            <p>No generated content yet.<br>Generate media to see it here!</p>
                        </div>
                    `;
                    // Hide the clear all button when gallery is empty
                    document.querySelector('.gallery-clear-all').style.display = 'none';
                    return;
                }
                
                const galleryGrid = document.createElement('div');
                galleryGrid.className = 'gallery-grid';
                
                for (const item of items) {
                    const galleryItem = document.createElement('div');
                    galleryItem.className = 'gallery-item';
                    
                    // Convert blob to URL for display
                    const dataUrl = URL.createObjectURL(item.data);
                    
                    const mediaElement = item.type === 'video' 
                        ? `<video class="gallery-item-media" src="${dataUrl}" muted></video>`
                        : `<img class="gallery-item-media" src="${dataUrl}" alt="Generated content">`;
                    
                    const typeIcon = item.type === 'video' ? '🎬' : '🎨';
                    
                    galleryItem.innerHTML = `
                        ${mediaElement}
                        <span class="gallery-item-type">${typeIcon}</span>
                        <button class="gallery-item-delete" data-action="delete-gallery-item" data-item-id="${item.id}">×</button>
                    `;
                    
                    // Add click handler for full-size viewing
                    galleryItem.addEventListener('click', (e) => {
                        // Don't open modal if delete button was clicked
                        if (e.target.classList.contains('gallery-item-delete') || e.target.getAttribute('data-action') === 'delete-gallery-item') return;
                        openModal(item.type, dataUrl, item);
                    });
                    
                    galleryGrid.appendChild(galleryItem);
                }
                
                galleryContent.innerHTML = '';
                galleryContent.appendChild(galleryGrid);
                
                // Show the clear all button when gallery has items
                document.querySelector('.gallery-clear-all').style.display = 'block';
                
            } catch (error) {
                console.error('Error loading gallery:', error);
                galleryContent.innerHTML = `
                    <div class="gallery-empty">
                        <div class="gallery-empty-icon">❌</div>
                        <p>Error loading gallery.<br>Please refresh the page to try again.</p>
                    </div>
                `;
                // Hide the clear all button on error
                document.querySelector('.gallery-clear-all').style.display = 'none';
            }
        }

        async function deleteGalleryItem(itemId, event) {
            event.stopPropagation(); // Prevent opening the modal
            if (confirm('Delete this item?')) {
                try {
                    const db = await initDB();
                    const transaction = db.transaction([STORE_NAME], 'readwrite');
                    const store = transaction.objectStore(STORE_NAME);
                    
                    await new Promise((resolve, reject) => {
                        const request = store.delete(itemId);
                        request.onsuccess = () => resolve();
                        request.onerror = () => reject(request.error);
                    });
                    
                    loadGallery();
                } catch (error) {
                    console.error('Error deleting gallery item:', error);
                    alert('Error deleting item: ' + error.message);
                }
            }
        }

        async function clearAllGallery() {
            if (confirm('Are you sure you want to clear all gallery items? This cannot be undone.')) {
                try {
                    const db = await initDB();
                    const transaction = db.transaction([STORE_NAME], 'readwrite');
                    const store = transaction.objectStore(STORE_NAME);
                    
                    await new Promise((resolve, reject) => {
                        const request = store.clear();
                        request.onsuccess = () => resolve();
                        request.onerror = () => reject(request.error);
                    });
                    
                    loadGallery();
                } catch (error) {
                    console.error('Error clearing gallery:', error);
                    alert('Error clearing gallery: ' + error.message);
                }
            }
        }

        function openModal(type, dataUrl, item) {
            const modal = document.getElementById('mediaModal');
            const modalImage = document.getElementById('modalImage');
            const modalVideo = document.getElementById('modalVideo');
            const modalPrompt = document.getElementById('modalPrompt');
            const modalSettings = document.getElementById('modalSettings');
            const modalDate = document.getElementById('modalDate');
            
            if (type === 'video') {
                modalImage.style.display = 'none';
                modalVideo.style.display = 'block';
                modalVideo.src = dataUrl;
            } else {
                modalVideo.style.display = 'none';
                modalImage.style.display = 'block';
                modalImage.src = dataUrl;
            }
            
            // Populate info panel
            modalPrompt.textContent = item.prompt;
            
            const settingsText = item.type === 'video'
                ? `Duration: ${item.settings.duration}s • Aspect: ${item.settings.aspectRatio} • Quality: ${item.settings.format}`
                : `Size: ${item.settings.size} • Quality: ${item.settings.quality} • Format: ${item.settings.outputFormat}`;
            
            modalSettings.textContent = settingsText;
            modalDate.textContent = `Generated on ${new Date(item.createdAt).toLocaleDateString()} at ${new Date(item.createdAt).toLocaleTimeString()}`;
            
            modal.classList.add('show');
        }

        function closeModal() {
            const modal = document.getElementById('mediaModal');
            const modalVideo = document.getElementById('modalVideo');
            
            modal.classList.remove('show');
            modalVideo.pause();
        }

        // Close modal when clicking outside the content
        document.getElementById('mediaModal').addEventListener('click', function(e) {
            if (e.target === this) {
                closeModal();
            }
        });

        // Service Worker Registration for PWA
        if ('serviceWorker' in navigator) {
            window.addEventListener('load', function() {
                navigator.serviceWorker.register('sw.js').then(function(registration) {
                    console.log('ServiceWorker registration successful with scope: ', registration.scope);
                }, function(err) {
                    console.log('ServiceWorker registration failed: ', err);
                });
            });
        }

        // PWA Install Banner Management
        let deferredPrompt;
        const DISMISS_DURATION = 48 * 60 * 60 * 1000; // 48 hours in milliseconds
        
        function isIOS() {
            return /iPad|iPhone|iPod/.test(navigator.userAgent) && !window.MSStream;
        }
        
        function isSafari() {
            return /Safari/.test(navigator.userAgent) && /Apple Computer/.test(navigator.vendor);
        }
        
        function isStandalone() {
            return window.matchMedia('(display-mode: standalone)').matches || 
                   window.navigator.standalone === true;
        }
        
        function shouldShowBanner() {
            // Don't show if already installed
            if (isStandalone()) return false;
            
            // Check if dismissed within last 48 hours
            const dismissedTime = localStorage.getItem('pwaBannerDismissed');
            if (dismissedTime) {
                const timePassed = Date.now() - parseInt(dismissedTime);
                if (timePassed < DISMISS_DURATION) return false;
            }
            
            return true;
        }
        
        function showPWABanner() {
            if (!shouldShowBanner()) return;
            
            const banner = document.getElementById('pwaInstallBanner');
            const installBtn = document.getElementById('pwaInstallBtn');
            const showInstructionsBtn = document.getElementById('pwaShowInstructions');
            const safariInstructions = document.getElementById('safariInstructions');
            
            // Configure for iOS Safari
            if (isIOS() && isSafari()) {
                showInstructionsBtn.style.display = 'inline-block';
                showInstructionsBtn.addEventListener('click', () => {
                    safariInstructions.style.display = safariInstructions.style.display === 'none' ? 'block' : 'none';
                });
            }
            
            banner.classList.add('show');
            document.body.classList.add('pwa-banner-visible');
        }
        
        function hidePWABanner() {
            const banner = document.getElementById('pwaInstallBanner');
            banner.classList.remove('show');
            document.body.classList.remove('pwa-banner-visible');
        }
        
        // PWA Install Event Listeners
        window.addEventListener('beforeinstallprompt', (e) => {
            e.preventDefault();
            deferredPrompt = e;
            
            const installBtn = document.getElementById('pwaInstallBtn');
            installBtn.style.display = 'inline-block';
            installBtn.addEventListener('click', async () => {
                if (deferredPrompt) {
                    deferredPrompt.prompt();
                    const { outcome } = await deferredPrompt.userChoice;
                    console.log(`User response to the install prompt: ${outcome}`);
                    if (outcome === 'accepted') {
                        hidePWABanner();
                    }
                    deferredPrompt = null;
                }
            });
            
            showPWABanner();
        });
        
        window.addEventListener('appinstalled', () => {
            console.log('PWA was installed');
            hidePWABanner();
            localStorage.removeItem('pwaBannerDismissed');
        });
        
        // Banner Button Event Listeners
        document.getElementById('pwaDismissBtn').addEventListener('click', () => {
            localStorage.setItem('pwaBannerDismissed', Date.now().toString());
            hidePWABanner();
        });
        
        document.getElementById('pwaLaterBtn').addEventListener('click', () => {
            localStorage.setItem('pwaBannerDismissed', Date.now().toString());
            hidePWABanner();
        });
        
        // Show banner on page load if conditions are met
        window.addEventListener('load', () => {
            // Delay showing banner slightly to avoid flash
            setTimeout(() => {
                if (!deferredPrompt && shouldShowBanner()) {
                    // For browsers that don't support beforeinstallprompt (like iOS Safari)
                    if (isIOS() || !('onbeforeinstallprompt' in window)) {
                        showPWABanner();
                    }
                }
            }, 1000);
        });
          // Clear all browser data function
          async function clearAllBrowserData() {
              const confirmMessage = 'This will permanently delete ALL data including:\n\n' +
                                   '• All generated images and videos\n' +
                                   '• Gallery history\n' +
                                   '• Background jobs\n' +
                                   '• App settings and preferences\n' +
                                   '• Service worker cache\n' +
                                   '• Your current session will be logged out\n\n' +
                                   'This action cannot be undone. Are you sure you want to continue?';

              if (confirm(confirmMessage)) {
                  try {
                      // Clear IndexedDB databases
                      if ('indexedDB' in window) {
                          // Clear gallery database
                          await new Promise((resolve, reject) => {
                              const deleteReq = indexedDB.deleteDatabase('AIGalleryDB');
                              deleteReq.onsuccess = () => resolve();
                              deleteReq.onerror = () => reject(deleteReq.error);
                          });

                          // Clear background jobs database
                          await new Promise((resolve, reject) => {
                              const deleteReq = indexedDB.deleteDatabase('BackgroundJobsDB');
                              deleteReq.onsuccess = () => resolve();
                              deleteReq.onerror = () => reject(deleteReq.error);
                          });
                      }

                      // Clear localStorage
                      localStorage.clear();

                      // Clear sessionStorage
                      sessionStorage.clear();

                      // Clear service worker caches
                      if ('serviceWorker' in navigator && 'caches' in window) {
                          const cacheNames = await caches.keys();
                          await Promise.all(
                              cacheNames.map(cacheName => caches.delete(cacheName))
                          );
                      }

                      // Unregister service worker
                      if ('serviceWorker' in navigator) {
                          const registrations = await navigator.serviceWorker.getRegistrations();
                          await Promise.all(
                              registrations.map(registration => registration.unregister())
                          );
                      }

                      // Clear HttpOnly authentication cookie by calling the logout endpoint.
                      // Client-side JavaScript cannot directly delete HttpOnly cookies.
                      // The server, upon receiving a /logout request, will clear its session cookie.
                      try {
                          const response = await fetch('/logout', { method: 'POST' });
                          if (!response.ok) {
                              console.warn('Logout request failed, server might not have cleared session cookie.', response.status);
                          } else {
                              console.log('Logout request successful, server should have cleared session cookie.');
                          }
                      } catch (fetchError) {
                          console.warn('Fetch call to /logout failed. Session cookie might not be cleared.', fetchError);
                      }

                      // Show success message briefly before reload
                      alert('All browser data has been cleared, and you have been logged out. The page will now reload.');

                      // Reload the page
                      window.location.reload(true);

                  } catch (error) {
                      console.error('Error clearing browser data:', error);
                      alert('Some data could not be cleared: ' + error.message + '\n\nPlease manually clear your browser data if needed.');
                  }
              }
          }
    </script>
</body>
</html>